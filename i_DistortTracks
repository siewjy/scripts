set cut_paste_input [stack 0]
version 13.2 v8
push $cut_paste_input
Group {
name i_DistortTracks
help "<b>Distort Tracks Gizmo</b>\n\n<b>About</b>:\nThis gizmo reformats and/or distorts tracking data based on a uv distortion map input. When you are working with CG elements in your comp that are undistorted and padded resolution, sometimes it is useful to reconcile tracking data from a 3d position through a camera into screen space. This data can then be used to do stuff in 2d: track in lens flares, matchmove roto or splinewarps, etc. The problem is that when this tracking data comes back from our padded undistorted 3d scene into distorted, unpadded resolution comp land, it doesn't line up. \n\n<b>Instructions</b>:\n1. Connect the UV input to a uv distortion map and set the channel that holds it, (for example, a LensDistortion node set to output type Displacement, outputting a UV distortion map into the forward.u and forward.v channels)\n2. Set the padded resolution format and the destination format: Padded resolution is the overscan resolution that you are distorting from, Destination format is the comp resolution you end up in. If they are the same, set them both to be the same.\n3. Add as many tracking points as you want and copy or link the data in. You can show or hide the input and output tracks for convenience. (It is easier to copy the data of many tracks in if you don't see the output track knobs.)\n4. Hit Execute, and all tracks will be distorted. The output tracking data will be copied into each tracks respective trk_out_# knob.\n\n<b>Notes</b>: \nNote that right now this only works with reformat types set to center, no resize, such as you would use when cropping a padded resolution cg plate back to comp resolution before distorting it. Theoretically this gizmo should work to 'reformat' tracking data as well. If you plug in an 'identity' uvmap, the tracking data should be undistorted, but reformatted from the source format to the destination format.\nAlso note that the distorted track output will switch to the reformatted track at the bounds of frame, so that the distorted track does not suddenly pop to 0,0 where the distortion map turns black.\n\nHuge thanks to Ivan Busquets for the ninja-comp technique used to invert the UV Map using a DisplaceGeo.\n\nCreated by Jed Smith. Comments and suggestions welcome: jedypod@gmail.com"
onCreate "n = nuke.thisNode()\n\nn\['refTrack'].setEnabled(False)"
knobChanged "# Sets the value of the uv_layer enumeration_knob to the list of input layers, \n# every time the input is changed\nfrom __future__ import with_statement \nn = nuke.thisNode()\nk = nuke.thisKnob()\n\nif k.name() == 'ToggleOutput':\n    for knob in n.knobs():\n        if 'trk_out_' in knob or 'delete_trk_' in knob:\n            if k.value() == True:\n                n\[knob].setVisible(True)\n            else:\n                n\[knob].setVisible(False)\n                \nif k.name() == 'ShowTracks':\n    for knob in n.knobs():\n        if 'track_' in knob or 'delete_trk_' in knob:\n            if k.value() == True:\n                n\[knob].setVisible(True)\n            else:\n                n\[knob].setVisible(False)\n                \nif k.name() == 'SmoothToggle':\n    for knob in n.knobs():\n        if 'smooth' in knob or 's_Value' in knob:\n            if k.value() == True:\n                n\[knob].setVisible(True)\n            else:\n                n\[knob].setVisible(False)\n"
tile_color 0xc2bcdcff
selected true
xpos -1376
ypos 1248
addUserKnob {20 DistortTracks}
addUserKnob {3 tnum l INVISIBLE +INVISIBLE}
addUserKnob {41 in l "uv layer" T SelectUV.in}
addUserKnob {6 identity_uv_map l "<b><font size=4>&nbsp;Identity UV Map</b>" t "Enable if you want no transformation. \n\nFor example, if you just want to reformat the tracking data from Padded Format to Destination Format." -STARTLINE +INVISIBLE}
addUserKnob {41 padded_format l "src format" t "This will be the format that the tracking data was created in. It will be transformed/distorted into the 'Root Format'." T PadFormat.format}
addUserKnob {41 destination_format l "dst format" t "If using a padded format as a source resolution, this will be the destination resolution for the 'distorted' tracking data." T DestinationFormat.format}
addUserKnob {26 spacer l " " T " "}
addUserKnob {6 idistort_map l "Use IDistort Map" t "Distorts tracking data with an iDistort map instead of an STMap compatible UV Map." +INVISIBLE +STARTLINE}
addUserKnob {6 animated_uvmap l "Animated Distortion Map" t "Check this if the input UVMap is animated. This will slow down analysis." -STARTLINE}
addUserKnob {7 precision l INVISIBLE t "Adjust the subdivide level of the uvmap invert - higher numbers result in increased accuracy at the expense of speed." +INVISIBLE R 2 16}
precision 10.2
addUserKnob {26 ""}
addUserKnob {22 add_track l "Add Track" t "Add another user track to process" T "# Add Track Data Button\ndef add_track():\n    # Note! A triple single-quoted comment breaks the python knob in nuke, causing to output tons of syntax error messages!\n    # Adds another track_data knob, and associated track_output knob, along with a button to remove both\n    n = nuke.thisNode()\n    #n = nuke.selectedNode()\n    # If range knob for this range num already exist, increment range number\n    tnum_knob = n\[\"tnum\"]\n    tnum = int(tnum_knob.getValue())\n    \n    tnum += 1\n    tnum_knob.setValue(tnum)\n    \n    delete_track_knob = nuke.PyScript_Knob(\"delete_trk_\{0\}\".format(tnum), \"Delete track_\{0\}\".format(tnum))\n    delete_track_knob.setFlag(nuke.STARTLINE)\n    n.addKnob(delete_track_knob)\n    delete_track_knob.setCommand('n = nuke.thisNode(); tnum = n\[\"tnum\"].value(); n\[\"tnum\"].setValue(tnum-1); n.removeKnob(n\[\"track_\{0\}\"]); n.removeKnob(n\[\"trk_out_\{0\}\"]); n.removeKnob(n\[\"smooth_\{0\}\"]); n.removeKnob(n\[\"delete_trk_\{0\}\"])'.format(tnum))\n    n.addKnob(nuke.XY_Knob(\"track_\{0\}\".format(tnum)))\n    n.addKnob(nuke.XY_Knob(\"trk_out_\{0\}\".format(tnum)))\n    n.addKnob(nuke.XY_Knob(\"smooth_\{0\}\".format(tnum)))\n    n\[\"smooth_\{0\}\".format(tnum)].setVisible(False)\n    \nif __name__==\"__main__\":\n    add_track()" +STARTLINE}
addUserKnob {22 add_2tracks l "Add 2 Tracks" -STARTLINE T "# Add Track Data Button\ndef add_track():\n    # Note! A triple single-quoted comment breaks the python knob in nuke, causing to output tons of syntax error messages!\n    # Adds another track_data knob, and associated track_output knob, along with a button to remove both\n    n = nuke.thisNode()\n    #n = nuke.selectedNode()\n    # If range knob for this range num already exist, increment range number\n    tnum_knob = n\[\"tnum\"]\n    tnum = int(tnum_knob.getValue())\n    \n    tnum += 1\n    tnum_knob.setValue(tnum)\n    \n    delete_track_knob = nuke.PyScript_Knob(\"delete_trk_\{0\}\".format(tnum), \"Delete track_\{0\}\".format(tnum))\n    delete_track_knob.setFlag(nuke.STARTLINE)\n    n.addKnob(delete_track_knob)\n    delete_track_knob.setCommand('n = nuke.thisNode(); tnum = n\[\"tnum\"].value(); n\[\"tnum\"].setValue(tnum-1); n.removeKnob(n\[\"track_\{0\}\"]); n.removeKnob(n\[\"trk_out_\{0\}\"]); n.removeKnob(n\[\"smooth_\{0\}\"]); n.removeKnob(n\[\"delete_trk_\{0\}\"])'.format(tnum))\n    n.addKnob(nuke.XY_Knob(\"track_\{0\}\".format(tnum)))\n    n.addKnob(nuke.XY_Knob(\"trk_out_\{0\}\".format(tnum)))\n    n.addKnob(nuke.XY_Knob(\"smooth_\{0\}\".format(tnum)))\n    n\[\"smooth_\{0\}\".format(tnum)].setVisible(False)\n    \nif __name__==\"__main__\":\n    add_track()\n    add_track()"}
addUserKnob {22 add_4tracks l "Add 4 Tracks" -STARTLINE T "# Add Track Data Button\ndef add_track():\n    # Note! A triple single-quoted comment breaks the python knob in nuke, causing to output tons of syntax error messages!\n    # Adds another track_data knob, and associated track_output knob, along with a button to remove both\n    n = nuke.thisNode()\n    #n = nuke.selectedNode()\n    # If range knob for this range num already exist, increment range number\n    tnum_knob = n\[\"tnum\"]\n    tnum = int(tnum_knob.getValue())\n    \n    tnum += 1\n    tnum_knob.setValue(tnum)\n    \n    delete_track_knob = nuke.PyScript_Knob(\"delete_trk_\{0\}\".format(tnum), \"Delete track_\{0\}\".format(tnum))\n    delete_track_knob.setFlag(nuke.STARTLINE)\n    n.addKnob(delete_track_knob)\n    delete_track_knob.setCommand('n = nuke.thisNode(); tnum = n\[\"tnum\"].value(); n\[\"tnum\"].setValue(tnum-1); n.removeKnob(n\[\"track_\{0\}\"]); n.removeKnob(n\[\"trk_out_\{0\}\"]); n.removeKnob(n\[\"smooth_\{0\}\"]); n.removeKnob(n\[\"delete_trk_\{0\}\"])'.format(tnum))\n    n.addKnob(nuke.XY_Knob(\"track_\{0\}\".format(tnum)))\n    n.addKnob(nuke.XY_Knob(\"trk_out_\{0\}\".format(tnum)))\n    n.addKnob(nuke.XY_Knob(\"smooth_\{0\}\".format(tnum)))\n    n\[\"smooth_\{0\}\".format(tnum)].setVisible(False)\n    \nif __name__==\"__main__\":\n    add_track()\n    add_track()\n    add_track()\n    add_track()"}
addUserKnob {6 ShowTracks l "Show Tracks" t "Toggle visibility of undistorted Tracking data" +STARTLINE}
ShowTracks true
addUserKnob {6 ToggleOutput l "Show Output" t "Show or Hide Track Output Knobs. This cleans up the UI when trying to copy tracking data into the track knobs." -STARTLINE}
ToggleOutput true
addUserKnob {20 advance l "Advanced Options" n 1}
addUserKnob {26 _info l "" +STARTLINE +INVISIBLE T "This function support Trackers with up to 4 tracks.\n"}
addUserKnob {22 setRef_Tracker l "Set Reference Tracker" T "refTrack = nuke.thisNode().knob('refTrack')\n\nwith nuke.root():\n    selected_node = nuke.selectedNode()\n    if \"Tracker\" in selected_node.name():\n        refTrack.setValue(selected_node.name())\n        \n    else:\n        nuke.message(\"Please Select a Tracker Node\")" +STARTLINE}
addUserKnob {1 refTrack l " Reference Tracker " -STARTLINE +DISABLED}
addUserKnob {22 copyTracks l "Copy Tracks from Tracker" T "def bakeCurve( curve, first, last, inc ):\n    '''bake an expresison curve into a keyframes curve'''\n    for f in range( first, last, inc ):\n        curve.setKey( f, curve.evaluate( f ) )\n    curve.setExpression( 'curve' )\n\n####################################################\ndef getCurves( knob, views ):\n    '''return a list of all animation curves found in the given knob'''\n    curves = \[]\n    for v in views:\n        curves.extend( knob.animations( v ) )\n    return curves\n\n####################################################\ndef bakeExpressionKnobs( node, first, last, inc, views ):  \n    '''bake all knobs in node that carry expressions'''\n    # GET ALL KNOBS WITH EXPRESSIONS IN THEM\n    expKnobs = \[ k for k in node.knobs().values() if k.hasExpression() ]\n\n    # GET ALL CURVES INSIDE THAT KNOB INCLUDING SPLIT FIELDS AND VIEWS\n    allCurves = \[]\n    for k in expKnobs:\n        allCurves += getCurves( k, views )\n\n    # BAKE ALL CURVES\n    for c in allCurves:\n        bakeCurve( c, first, last, inc )        \n\n####################################################\ndef bakeSelectedNodes():\n    '''bake selected nodes' knobs that carry expressions'''\n    ret = nuke.getFramesAndViews( 'Select Frame Range', '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    n = nuke.thisNode()\n    bakeExpressionKnobs( n, fRange.first(), fRange.last()+1, fRange.increment(), views )\n\n####################################################\n\nthis = nuke.thisNode()\ns_name = this\[\"refTrack\"].value()\ntnum = int(this\[\"tnum\"].value())\nthis_name = this.name()\n\nnum = 0\n\nif not tnum == 0:\n\n    if not s_name == \"\":\n        \n        selected_node = nuke.toNode(s_name)\n        t_class = selected_node.Class()\n        \n        for i in range(tnum):\n        \n            num += 1\n            num_str = str(num) \n            \n            track_x = this_name + \".track_\" + num_str + \".x\"\n            track_y = this_name + \".track_\" + num_str + \".y\"\n            \n            if t_class == \"Tracker3\":\n                source_x = s_name + \".track\" + num_str + \".x\"\n                source_y = s_name + \".track\" + num_str + \".y\"\n            \n            elif t_class == \"Tracker4\":\n                source_x = s_name + \".tracks.\" + num_str + \".track_x\"\n                source_y = s_name + \".tracks.\" + num_str + \".track_y\"\n            \n            nuke.animation(track_x, \"expression\", (source_x,))\n            nuke.animation(track_y, \"expression\", (source_y,))\n        \n        bakeSelectedNodes()\n        \n        num = 0\n        \n        for i in range(tnum):\n            \n            num += 1\n            num_str = str(num) \n            \n            #track1.x.integrate(frame-s_Value, frame+s_Value) / (2*s_Value)\n            \n            smooth_knob = \"smooth_\" + num_str\n    \n            smoooth_x = \"trk_out_\" + num_str + \".x.integrate(frame-s_Value, frame+s_Value) / (2*s_Value)\"\n            smoooth_y = \"trk_out_\" + num_str + \".y.integrate(frame-s_Value, frame+s_Value) / (2*s_Value)\"\n            \n            n\[smooth_knob].setExpression(smoooth_x, 0)\n            n\[smooth_knob].setExpression(smoooth_y, 1)\n        \n    else:\n        nuke.message(\"Please set a Tracker as Reference!\")\n        \nelse:\n    nuke.message(\"Please Add Tracks before Copying Tracks\")\n        " +STARTLINE}
addUserKnob {20 endGroup n -1}
addUserKnob {26 ""}
addUserKnob {26 text_02 l "" +STARTLINE T "Apply Distortion to Trackers"}
addUserKnob {22 execute l Execute t "Analyze UV Map pixel values at locations specified by tracking data in 'Track', then copy calculated offset track into 'Track Output'." T "from __future__ import with_statement \nfrom __future__ import print_function\n\ndef distort_track_data():\n    \"\"\" Code to go in the \"Execute\" button of the DistortTracks node\n    \"\"\"\n    n = nuke.thisNode()\n    padded_format = n\['padded_format'].value()\n    destination_format = n\['destination_format'].value()\n    # Set Padded and Destination Format Resolutions. You sample a 'format' knob's value() with .width() and .height()\n    pad_res = \[int(padded_format.width()), int(padded_format.height())]\n    dest_res = \[int(destination_format.width()), int(destination_format.height())]\n    # Assume uvmap does not animate, for faster sampling of uvmap colors.\n    uvmap_animation = False\n\n\n    track_list = \[]\n    for knob in n.knobs():\n        if 'track_' in knob:\n            track_list.append(n\[knob])\n    for track in track_list:\n        track_number = track.name().split('_')\[-1]\n        output = n.knob('trk_out_\{0\}'.format(track_number))\n        output.setAnimated()\n        channels = \['rgba.red', 'rgba.green']\n\n        with n:\n            curveTool = nuke.toNode('CurveTool')\n            crop_to1px = nuke.toNode('CropToReformatTrack')\n            framehold = nuke.toNode('MasterFramehold')\n\n            # destination_format = nuke.toNode('DestinationFormat').knob('format').value()\n            # padded_format = nuke.toNode('PadFormat1').knob('format').value()\n        crop_to1px\['pos'].clearAnimated()\n        crop_to1px\['pos'].setAnimated()\n        reformatted_track_position = crop_to1px\['pos'].animations()\n\n        # Handle case if Track knob has expression instead of keyframes\n        # Remove expression and copy each keyframe from source knob to this knob\n        if track.hasExpression(0) and track.hasExpression(1):\n            orig_exp = track.animation(0).expression().split('.')\n            print(\"to - \", orig_exp\[1])\n            trk_srcnode = nuke.toNode(orig_exp\[1])\n            trk_srcknob = trk_srcnode\[orig_exp\[2]]\n            track.clearAnimated()\n            track.setAnimated()\n            if trk_srcnode.Class() == 'Tracker4':\n                # Deal with expression links to Tracker4 nodes\n                # http://forums.thefoundry.co.uk/phpBB2/viewtopic.php?t=8130\n                # http://forums.thefoundry.co.uk/phpBB2/viewtopic.php?t=8245\n                track_index = int(orig_exp\[3])-1\n                ch_x = 31*track_index + 2\n                ch_y = 31*track_index + 3\n                # Use the root framerange for tracker range - not possible to determine animation range\n                fr = nuke.root().frameRange()\n                for f in range(fr.first(), fr.last()):\n                    track.animation(0).setKey(f, trk_srcknob.getValueAt(f, ch_x))\n                    track.animation(1).setKey(f, trk_srcknob.getValueAt(f, ch_y))\n            else:\n                for index in \[0, 1]:\n                    track_knob_animcurve = track.animation(index)\n                    track_knob_animcurve.addKey(trk_srcknob.animation(index).keys())\n\n        # Get first and last keyframes on \"track\" animation curve\n        track_data = track.animations()\n\n        first_keyframe_x = int(track_data\[0].keys()\[0].x)\n        last_keyframe_x = int(track_data\[0].keys()\[-1].x+1)\n        first_keyframe_y = int(track_data\[1].keys()\[0].x)\n        last_keyframe_y = int(track_data\[1].keys()\[-1].x+1)\n\n        print(\"Animation range x is\", first_keyframe_x, last_keyframe_x)\n        print(\"Animation range y is\", first_keyframe_y, last_keyframe_y)\n\n        # Reformat Track Position Data\n        # Get difference in source and destination formats. This assumes 'resize type: none, center' reformat, \n        # for example, for removing padded pixels before applying lens distortion to cg\n        pad_diff = \[(pad_res\[0] - dest_res\[0]) / 2, (pad_res\[1] - dest_res\[1]) / 2]\n        print(\"Pad Difference is (\{0\}x\{1\} - \{2\}x\{3\})/2 = \{4\}x\{5\}\".format(padded_format.width(), padded_format.height(), destination_format.width(), destination_format.height(), pad_diff\[0], pad_diff\[1]))\n\n        # Find smallest first_keyframe and biggest last_keyframe - in case there are keys in one dimension that are not in the other\n        if first_keyframe_x < first_keyframe_y:\n            first_keyframe = first_keyframe_x\n        else:\n            first_keyframe = first_keyframe_y\n        if last_keyframe_x > last_keyframe_y:\n            last_keyframe = last_keyframe_x\n        else:\n            last_keyframe = last_keyframe_y\n        if uvmap_animation == False:\n            framehold.knob('first_frame').setValue(first_keyframe)\n        \n        \"\"\"\n        ################################\n        # How STMapping Works\n        ################################\n        http://forums.thefoundry.co.uk/phpBB2/viewtopic.php?t=2398&sid=a2e5572da996cc31235f4b5d606b8ec5\n        http://forums.thefoundry.co.uk/phpBB2/viewtopic.php?p=3015&sid=7705835d3af32b8371ab7f4af5815bc9\n        Every pixel of the uvmap represents the source pixel location. For example, a uvmap pixel says \"use the pixel from this location as me!\"\n        That location is encoded as floating point values, which represent fractions of width and height. For example, x position 512 in a 1080p frame would be encoded as 1920/512 = .26666667\n        On a MergeExpression node, an stmap operation basically is this: for every pixel in B, use the pixel from the coordinates specified by the pixel in A (the UVMAP).\n        Br(Ar*width, Ag*height) <- that is an stmap with impulse filtering on the red channel\n\n        To invert the stmap, for every pixel you would have to find the SourcePixel, and in that pixel's location, put the current pixelCoordinates.\n            Or: in each pixel's location, put the pixelCoordinates of the pixel that references this pixel's location\n        To map from Undistorted to Distorted position, you need to lookup the pixel value at the undistorted position in the undistort uvmap, OR lookup the pixel value at the distorted position in the re-distort map. \n            The second is not possible without trial and error, because we are trying to find the distorted position.\n\n        You can't do this to the distortion map using an expression node, but you are not limited to this. \n        \"\"\"\n\n        # Create reformatted track data, so we can sample the uv map in the correct place post-reformat\n        for i in \[0, 1]:\n            for frame in range(first_keyframe, last_keyframe):\n                reformatted_track_position\[i].setKey(frame, track_data\[i].evaluate(frame) - pad_diff\[i])\n        # Execute the curvetool with the correct framerange and a frame increment of 1,\n        # To get UV pixel values at each point of the reformatted tracking data\n        nuke.executeMultiple(\[curveTool,], (\[first_keyframe, last_keyframe, 1],))\n        uv_data = curveTool.knob('intensitydata').animations()\n        \n\n        # Loop through all keyframes, get distorted 2d position values using reformatted track positions\n        # and UV distortion data from curveTool analysis. Apply this data to track_output knob\n        for i in \[0,1]:\n            for frame in range(first_keyframe, last_keyframe):\n                reformatted_pos = reformatted_track_position\[i].evaluate(frame)\n                original_pos = track_data\[i].evaluate(frame)\n                #if original_pos <= 0 or original_pos >= dest_res\[i]:\n                if uv_data\[i].evaluate(frame) == 0:\n                     # Use the original reformat track data if the position is outside of the inverted uvmap bounds makes the distorted track at least slight resemble the original outside of the frame bounds instead of being zero\n                     #print('uv data is zero, using reformatted track!')\n                     output.setValueAt( reformatted_pos, frame, i )\n                else:\n                    # Use the pixel coordinates that the uvmap points to at the 'reformatted track' pixel location.\n                    output.setValueAt( uv_data\[i].evaluate(frame) * dest_res\[i], frame, i )  \n                print(\"Frame \{0:04d\} - \{1\} -> \{2\} --> \{3\} -- uv vals \{4\}\".format(frame, round(track_data\[i].evaluate(frame), 2), round(reformatted_pos, 2), uv_data\[i].evaluate(frame) * dest_res\[i], uv_data\[i].evaluate(frame)))\n\nif __name__==\"__main__\":\n    distort_track_data()" +STARTLINE}
addUserKnob {26 text_02_1 l "" +STARTLINE T "\nExport Tracks"}
addUserKnob {22 exportTracks l "Export to Tracker" T "n = nuke.thisNode()\n\nnum = 0\nid = -1\n\n# Create New Tracker\ncount = int(n\[\"tnum\"].value())\n\nif not count == 0:\n    with nuke.root():\n        new = nuke.createNode('Tracker4')\n        for i in range(count):\n            new\['add_track'].execute()\n                \n            \n    #Transfer to New Tracker\n    first = int(nuke.Root()\['first_frame'].value())\n    last = int(nuke.Root()\['last_frame'].value())\n    \n    #Position\n    new.setXpos(n.xpos()+0)\n    new.setYpos(n.ypos()+75)\n    new.setInput(0, None)\n    \n    frames = range(first, last+1)\n    \n    k_tracks = new\['tracks']\n    \n    numColumns = 31\n    \n    for i in range(count):\n        num += 1\n        num_str = str(num)\n        \n        id += 1\n        \n        trackId = id\n        trk_out = \"trk_out_\" + num_str\n        t_curves = n\[trk_out].animations()\n        \n        print(trackId)\n        \n        for f in frames:\n            for i, curve in enumerate(t_curves):\n                k_tracks.setValueAt(curve.evaluate(f), f, numColumns*trackId + (2+i))\n    \nelse:    \n    nuke.message(\"Add Tracks and apply Distortion to it before Exporting\")\n    \n    \n    \n        " +STARTLINE}
addUserKnob {22 export_CornerPin l "Export to CornerPin2D" -STARTLINE T "def bakeCurve( curve, first, last, inc ):\n    '''bake an expresison curve into a keyframes curve'''\n    for f in range( first, last, inc ):\n        curve.setKey( f, curve.evaluate( f ) )\n    curve.setExpression( 'curve' )\n\n####################################################\ndef getCurves( knob, views ):\n    '''return a list of all animation curves found in the given knob'''\n    curves = \[]\n    for v in views:\n        curves.extend( knob.animations( v ) )\n    return curves\n\n####################################################\ndef bakeExpressionKnobs( node, first, last, inc, views ):  \n    '''bake all knobs in node that carry expressions'''\n    # GET ALL KNOBS WITH EXPRESSIONS IN THEM\n    expKnobs = \[ k for k in node.knobs().values() if k.hasExpression() ]\n\n    # GET ALL CURVES INSIDE THAT KNOB INCLUDING SPLIT FIELDS AND VIEWS\n    allCurves = \[]\n    for k in expKnobs:\n        allCurves += getCurves( k, views )\n\n    # BAKE ALL CURVES\n    for c in allCurves:\n        bakeCurve( c, first, last, inc )\n\n####################################################\ndef bakeSelectedNodes():\n    '''bake selected nodes' knobs that carry expressions'''\n    ret = nuke.getFramesAndViews( 'Set Frame Range', '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    bakeExpressionKnobs( new_c , fRange.first(), fRange.last()+1, fRange.increment(), views )\n\n####################################################\n\nn = nuke.thisNode()\n\n# Create New CornerPin Node\ncount = int(n\[\"tnum\"].value())\n\nif not count == 4:\n    nuke.message(\"4 Tracks are required to export as CornerPin\")\n    \nelse:\n    with nuke.root():\n        new_c = nuke.createNode('CornerPin2D')\n        \n        num = 0\n        cp_name = new_c.name()\n        n_name = n.name()\n        \n        for i in range(count):\n            num += 1\n            num_str = str(num)\n            \n            to_x = cp_name + \".to\" + num_str + \".x\"\n            to_y = cp_name + \".to\" + num_str + \".y\"\n    \n            trk_x = n_name + \".trk_out_\" + num_str + \".x\"\n            trk_y = n_name + \".trk_out_\" + num_str + \".y\"\n    \n            nuke.animation(to_x, \"expression\" , (trk_x,))\n            nuke.animation(to_y, \"expression\" , (trk_y,))\n            \n            from_x = cp_name + \".from\" + num_str + \".x\"\n            from_y = cp_name + \".from\" + num_str + \".y\"\n            \n            nuke.animation(from_x, \"expression\" , (trk_x,))\n            nuke.animation(from_y, \"expression\" , (trk_y,))\n            \n            #Clear \"From\" animations\n            \n            fr = \"from\" + num_str\n            new_c\[fr].clearAnimated()\n        \n        bakeSelectedNodes()\n        \n        new_c.setInput(0, None)\n        ref_Frame = nuke.PyScript_Knob(\"setRefFrame\", \"Set Reference Frame\", \"Text\")\n        new_c.addKnob(ref_Frame)\n        new_c.knob('setRefFrame').setValue(\"refFrame = nuke.thisNode()\\ncurrentFrame = nuke.frame()\\n\\n\\nnuke.animation(\\\"from1.x\\\",\\\"expression\\\",(\\\"to1.x\\\",))\\nnuke.animation(\\\"from2.x\\\",\\\"expression\\\",(\\\"to2.x\\\",))\\nnuke.animation(\\\"from3.x\\\",\\\"expression\\\",(\\\"to3.x\\\",))\\nnuke.animation(\\\"from4.x\\\",\\\"expression\\\",(\\\"to4.x\\\",))\\n\\n\\nnuke.animation(\\\"from1.y\\\",\\\"expression\\\",(\\\"to1.y\\\",))\\nnuke.animation(\\\"from2.y\\\",\\\"expression\\\",(\\\"to2.y\\\",))\\nnuke.animation(\\\"from3.y\\\",\\\"expression\\\",(\\\"to3.y\\\",))\\nnuke.animation(\\\"from4.y\\\",\\\"expression\\\",(\\\"to4.y\\\",))\\n\\n\\nrefFrame\['from1'].clearAnimated()\\nrefFrame\['from2'].clearAnimated()\\nrefFrame\['from3'].clearAnimated()\\nrefFrame\['from4'].clearAnimated()\\n\\nrefFrame.knob('r_frame').setValue(currentFrame)\\nrefFrame.knob('r_frame').setEnabled(False)\")\n    \n        frameNo = nuke.Int_Knob(\"r_frame\", \" Frame\", 0)\n        new_c.addKnob(frameNo)\n        new_c\['r_frame'].clearFlag(nuke.STARTLINE)\n        new_c\['r_frame'].setEnabled(False)\n        current = nuke.frame()\n        new_c\['r_frame'].setValue(current)\n    \n        #Label \n        p_label = new_c\['label'].value()\n        p_label_lines = p_label.split('\\n')\n        p_label_top = p_label_lines\[0]\n        new_c\['label'].setValue(p_label_top+\"\\nRef Frame: \[value r_frame]\")\n        new_c.knob('User').setLabel(\"Set Reference Frame\")\n        \n        #Position\n        new_c.setXpos(n.xpos()+0)\n        new_c.setYpos(n.ypos()+75)\n            "}
addUserKnob {6 SmoothToggle l "Show \"Smooth Tracks\" Options" +STARTLINE}
addUserKnob {7 s_Value l Smooth +HIDDEN R 0.1 3}
s_Value 1
addUserKnob {22 exportTrack_smooth l "Export to Tracker (Smooth)" +HIDDEN T "n = nuke.thisNode()\n\nnum = 0\nid = -1\n\n# Create New Tracker\ncount = int(n\[\"tnum\"].value())\n\nif not count == 0:\n    with nuke.root():\n        new = nuke.createNode('Tracker4')\n        for i in range(count):\n            new\['add_track'].execute()\n                \n            \n    #Transfer to New Tracker\n    first = int(nuke.Root()\['first_frame'].value())\n    last = int(nuke.Root()\['last_frame'].value())\n    \n    #Position\n    new.setXpos(n.xpos()+0)\n    new.setYpos(n.ypos()+75)\n    new.setInput(0, None)\n    \n    frames = range(first, last+1)\n    \n    k_tracks = new\['tracks']\n    \n    numColumns = 31\n    \n    for i in range(count):\n        num += 1\n        num_str = str(num)\n        \n        id += 1\n        \n        trackId = id\n        trk_out = \"smooth_\" + num_str\n        t_curves = n\[trk_out].animations()\n        \n        print(trackId)\n        \n        for f in frames:\n            for i, curve in enumerate(t_curves):\n                k_tracks.setValueAt(curve.evaluate(f), f, numColumns*trackId + (2+i))\n    \nelse:    \n    nuke.message(\"Add Tracks and apply Distortion to it before Exporting\")\n    \n    \n    \n        " +STARTLINE}
addUserKnob {22 export_CornerPin_smooth l "Export to CornerPin2D (Smooth)" -STARTLINE +HIDDEN T "def bakeCurve( curve, first, last, inc ):\n    '''bake an expresison curve into a keyframes curve'''\n    for f in range( first, last, inc ):\n        curve.setKey( f, curve.evaluate( f ) )\n    curve.setExpression( 'curve' )\n\n####################################################\ndef getCurves( knob, views ):\n    '''return a list of all animation curves found in the given knob'''\n    curves = \[]\n    for v in views:\n        curves.extend( knob.animations( v ) )\n    return curves\n\n####################################################\ndef bakeExpressionKnobs( node, first, last, inc, views ):  \n    '''bake all knobs in node that carry expressions'''\n    # GET ALL KNOBS WITH EXPRESSIONS IN THEM\n    expKnobs = \[ k for k in node.knobs().values() if k.hasExpression() ]\n\n    # GET ALL CURVES INSIDE THAT KNOB INCLUDING SPLIT FIELDS AND VIEWS\n    allCurves = \[]\n    for k in expKnobs:\n        allCurves += getCurves( k, views )\n\n    # BAKE ALL CURVES\n    for c in allCurves:\n        bakeCurve( c, first, last, inc )\n\n####################################################\ndef bakeSelectedNodes():\n    '''bake selected nodes' knobs that carry expressions'''\n    ret = nuke.getFramesAndViews( 'Set Frame Range', '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    bakeExpressionKnobs( new_c , fRange.first(), fRange.last()+1, fRange.increment(), views )\n\n####################################################\n\nn = nuke.thisNode()\n\n# Create New CornerPin Node\ncount = int(n\[\"tnum\"].value())\n\nif not count == 4:\n    nuke.message(\"4 Tracks are required to export as CornerPin\")\n    \nelse:\n    with nuke.root():\n        new_c = nuke.createNode('CornerPin2D')\n        \n        num = 0\n        cp_name = new_c.name()\n        n_name = n.name()\n        \n        for i in range(count):\n            num += 1\n            num_str = str(num)\n            \n            to_x = cp_name + \".to\" + num_str + \".x\"\n            to_y = cp_name + \".to\" + num_str + \".y\"\n    \n            trk_x = n_name + \".smooth_\" + num_str + \".x\"\n            trk_y = n_name + \".smooth_\" + num_str + \".y\"\n    \n            nuke.animation(to_x, \"expression\" , (trk_x,))\n            nuke.animation(to_y, \"expression\" , (trk_y,))\n            \n            from_x = cp_name + \".from\" + num_str + \".x\"\n            from_y = cp_name + \".from\" + num_str + \".y\"\n            \n            nuke.animation(from_x, \"expression\" , (trk_x,))\n            nuke.animation(from_y, \"expression\" , (trk_y,))\n            \n            #Clear \"From\" animations\n            \n            fr = \"from\" + num_str\n            new_c\[fr].clearAnimated()\n        \n        bakeSelectedNodes()\n        \n        new_c.setInput(0, None)\n        ref_Frame = nuke.PyScript_Knob(\"setRefFrame\", \"Set Reference Frame\", \"Text\")\n        new_c.addKnob(ref_Frame)\n        new_c.knob('setRefFrame').setValue(\"refFrame = nuke.thisNode()\\ncurrentFrame = nuke.frame()\\n\\n\\nnuke.animation(\\\"from1.x\\\",\\\"expression\\\",(\\\"to1.x\\\",))\\nnuke.animation(\\\"from2.x\\\",\\\"expression\\\",(\\\"to2.x\\\",))\\nnuke.animation(\\\"from3.x\\\",\\\"expression\\\",(\\\"to3.x\\\",))\\nnuke.animation(\\\"from4.x\\\",\\\"expression\\\",(\\\"to4.x\\\",))\\n\\n\\nnuke.animation(\\\"from1.y\\\",\\\"expression\\\",(\\\"to1.y\\\",))\\nnuke.animation(\\\"from2.y\\\",\\\"expression\\\",(\\\"to2.y\\\",))\\nnuke.animation(\\\"from3.y\\\",\\\"expression\\\",(\\\"to3.y\\\",))\\nnuke.animation(\\\"from4.y\\\",\\\"expression\\\",(\\\"to4.y\\\",))\\n\\n\\nrefFrame\['from1'].clearAnimated()\\nrefFrame\['from2'].clearAnimated()\\nrefFrame\['from3'].clearAnimated()\\nrefFrame\['from4'].clearAnimated()\\n\\nrefFrame.knob('r_frame').setValue(currentFrame)\\nrefFrame.knob('r_frame').setEnabled(False)\")\n    \n        frameNo = nuke.Int_Knob(\"r_frame\", \" Frame\", 0)\n        new_c.addKnob(frameNo)\n        new_c\['r_frame'].clearFlag(nuke.STARTLINE)\n        new_c\['r_frame'].setEnabled(False)\n        current = nuke.frame()\n        new_c\['r_frame'].setValue(current)\n    \n        #Label \n        p_label = new_c\['label'].value()\n        p_label_lines = p_label.split('\\n')\n        p_label_top = p_label_lines\[0]\n        new_c\['label'].setValue(p_label_top+\"\\nRef Frame: \[value r_frame]\")\n        new_c.knob('User').setLabel(\"Set Reference Frame\")\n        \n        #Position\n        new_c.setXpos(n.xpos()+0)\n        new_c.setYpos(n.ypos()+75)\n            "}
addUserKnob {26 ""}
}
BackdropNode {
inputs 0
name BackdropNode1
tile_color 0x4c4c4c01
label " Invert UV Map"
note_font_size 100
note_font_color 0x1e1e1eff
xpos 155
ypos 422
bdwidth 791
bdheight 644
}
Input {
inputs 0
name UV
label "\[value number]"
xpos 180
ypos -638
}
Dot {
name Dot6
label " Input"
note_font_size 42
note_font_color 0x7f7f7f01
xpos 211
ypos -558
}
Constant {
inputs 0
name Constant2
xpos 400
ypos -441
}
Switch {
inputs 2
which {{"\[exists parent.input0]"}}
name Switch3
xpos 180
ypos -417
}
Shuffle {
blue black
alpha black
name SelectUV
xpos 180
ypos -298
}
Remove {
operation keep
channels {rgba.red rgba.green -rgba.blue none}
name Remove1
xpos 180
ypos -248
}
set N223fa750 [stack 0]
Expression {
expr0 (x+0.5)/(width)
expr1 (y+0.5)/(height)
name Expression1
label "UV map"
xpos 290
ypos -254
}
Dot {
name Dot2
note_font_size 42
note_font_color 0x7f7f7f01
xpos 321
ypos -177
}
push $N223fa750
Switch {
inputs 2
which {{parent.identity_uv_map}}
name Switch2
label "Identity UV Map Pass-Through"
xpos 180
ypos -184
addUserKnob {20 Timing}
addUserKnob {3 range_num +HIDDEN}
range_num 1
addUserKnob {22 add_range l "Add Range" -STARTLINE T "def add_range():\n    n = nuke.thisNode()\n    #n = nuke.selectedNode()\n    whichknob = n.knob('which')\n    rnum = n.knob('range_num').value()\n    # If range knob for this range num already exist, increment range number\n    if n.knob('range_\{0\}'.format(rnum)) != None:\n        rnum += 1\n        n.knob('range_num').setValue(rnum)\n    sfname = 'startframe_\{0\}'.format(rnum)\n    efname = 'endframe_\{0\}'.format(rnum)\n    n.addKnob(nuke.Text_Knob('range_\{0\}'.format(rnum), 'range_\{0\}'.format(rnum)))\n    n.addKnob(nuke.Int_Knob(sfname, 'Start Frame'))\n    n.addKnob(nuke.Int_Knob(efname, 'End Frame'))\n    n.knob(sfname).setValue(int(nuke.root()\['first_frame'].getValue()))\n    n.knob(efname).setValue(int(nuke.root()\['last_frame'].getValue()))\n    \n    if whichknob.hasExpression():\n        whichknob.setExpression(whichknob.animation(0).expression() + \" || (frame >= \{0\} && frame <= \{1\})\".format(sfname, efname))\n    else:\n        whichknob.setExpression('(frame >= \{0\} && frame <= \{1\})'.format(sfname, efname))\n    n.knob('label').setValue('Range \[value \{0\}]-\[value \{1\}]'.format(sfname, efname))\nif __name__==\"__main__\":\n    add_range()"}
}
Dot {
name Dot16
note_font_size 42
note_font_color 0x7f7f7f01
xpos 211
ypos -102
}
set N23aebee0 [stack 0]
Dot {
name Dot14
label " IDistort Style Map Input"
note_font_size 24
note_font_color 0x7f7f7f01
xpos 321
ypos -102
}
Expression {
expr0 (r+x)/width
expr1 (g+y)/height
expr2 0
name IDistort_To_UVMap
xpos 290
ypos -57
}
set N28cebdd0 [stack 0]
push $N23aebee0
Switch {
inputs 2
which {{parent.idistort_map}}
name Switch1
xpos 180
ypos -57
addUserKnob {20 Timing}
addUserKnob {3 range_num +HIDDEN}
range_num 1
addUserKnob {22 add_range l "Add Range" -STARTLINE T "def add_range():\n    n = nuke.thisNode()\n    #n = nuke.selectedNode()\n    whichknob = n.knob('which')\n    rnum = n.knob('range_num').value()\n    # If range knob for this range num already exist, increment range number\n    if n.knob('range_\{0\}'.format(rnum)) != None:\n        rnum += 1\n        n.knob('range_num').setValue(rnum)\n    sfname = 'startframe_\{0\}'.format(rnum)\n    efname = 'endframe_\{0\}'.format(rnum)\n    n.addKnob(nuke.Text_Knob('range_\{0\}'.format(rnum), 'range_\{0\}'.format(rnum)))\n    n.addKnob(nuke.Int_Knob(sfname, 'Start Frame'))\n    n.addKnob(nuke.Int_Knob(efname, 'End Frame'))\n    n.knob(sfname).setValue(int(nuke.root()\['first_frame'].getValue()))\n    n.knob(efname).setValue(int(nuke.root()\['last_frame'].getValue()))\n    \n    if whichknob.hasExpression():\n        whichknob.setExpression(whichknob.animation(0).expression() + \" || (frame >= \{0\} && frame <= \{1\})\".format(sfname, efname))\n    else:\n        whichknob.setExpression('(frame >= \{0\} && frame <= \{1\})'.format(sfname, efname))\n    n.knob('label').setValue('Range \[value \{0\}]-\[value \{1\}]'.format(sfname, efname))\nif __name__==\"__main__\":\n    add_range()"}
}
Dot {
name Dot15
note_font_size 42
note_font_color 0x7f7f7f01
xpos 214
ypos 66
}
set N2d97b7a0 [stack 0]
Dot {
name Dot8
note_font_size 42
note_font_color 0x7f7f7f01
xpos 104
ypos 66
}
Dot {
name Dot1
label " Output UV Map for Preview"
note_font_size 42
note_font_color 0x7f7f7f01
xpos 104
ypos 1362
}
Output {
name Output1
xpos 70
ypos 1455
}
Constant {
inputs 0
channels rgb
format {{{parent.DestinationFormat.format}}}
name Constant1
xpos 400
ypos 759
}
Reformat {
resize none
pbb true
name DestinationFormat
xpos 400
ypos 879
}
set N2f114520 [stack 0]
Reformat {
resize none
name PadFormat
xpos 400
ypos 922
}
Camera2 {
inputs 0
translate {0 0 1}
focal 24.576
name Camera1
xpos 740
ypos 858
}
push $N2d97b7a0
Dot {
name Dot9
label " Input Distortion Map"
note_font_size 42
note_font_color 0x7f7f7f01
xpos 434
ypos 66
}
Grade {
add -0.5
black_clamp false
name Grade4
xpos 400
ypos 663
}
Grade {
multiply {1 {height/width} 1 1}
black_clamp false
name Grade5
xpos 400
ypos 687
}
push $N2d97b7a0
Dot {
name Dot12
note_font_size 42
note_font_color 0x7f7f7f01
xpos 214
ypos 258
}
Dot {
name Dot11
label " Identity UV Map"
note_font_size 42
note_font_color 0x7f7f7f01
xpos 654
ypos 258
}
Remove {
operation keep
channels {rgba.red rgba.green -rgba.blue none}
name Remove2
xpos 620
ypos 276
}
Expression {
expr0 (x+0.5)/(width)
expr1 (y+0.5)/(height)
name Expression6
label "UV map"
xpos 620
ypos 323
}
Card2 {
rows {{input.width/divisions}}
columns {{input.height/divisions}}
control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
name Card2
xpos 620
ypos 567
addUserKnob {20 User}
addUserKnob {3 divisions}
divisions {{rint(parent.precision)}}
}
DisplaceGeo {
inputs 2
source "rgb absolute"
scale 1
name DisplaceGeo2
xpos 620
ypos 687
}
FrameHold {
firstFrame {{parent.MasterFramehold.knob.first_frame}}
name SlaveFramehold1
xpos 620
ypos 754
disable {{parent.MasterFramehold.disable}}
}
push $N2f114520
ScanlineRender {
inputs 3
overscan {{(PadFormat.format.width/DestinationFormat.format.width-1)*PadFormat.format.width} {(PadFormat.format.height/DestinationFormat.format.height-1)*PadFormat.format.height}}
motion_vectors_type distance
name ScanlineRender1
xpos 620
ypos 879
}
FrameHold {
firstFrame 1016
name MasterFramehold
label "assume non-animated distortion map"
xpos 620
ypos 940
disable {{parent.animated_uvmap}}
}
Crop {
box {{"pos.x - boxsize/2"} {"pos.y - boxsize/2"} {box.x+boxsize} {box.y+boxsize}}
reformat true
crop false
name CropToReformatTrack
xpos 620
ypos 1167
addUserKnob {20 CTRL l Controls}
addUserKnob {7 boxsize R 1 10}
boxsize 1
addUserKnob {12 pos}
pos {{curve x1016 2712.621094 2712.621094 2711.58374 2710.543945 2709.493896 2708.441162 2707.394043 2706.360596 2705.332275 2704.30249 2703.266113 2702.227539 2701.185303 2700.12793 2699.068848 2698.028076 2697.02417 2696.039795 2695.065918 2694.10791 2693.158203 2692.195068 2691.192871 2690.177246 2689.175049 2688.212158 2687.262939 2686.302002 2685.305908 2684.297363 2683.295654 2682.31958 2681.349609 2680.359619 2679.331299 2678.281982 2677.21875 2676.134766 2675.03833 2673.945312 2672.857422 2671.77417 2670.709473 2669.679932 2668.668213 2667.657227 2666.639648 2665.62085 2664.597656 2663.557861 2662.514404 2661.486816 2660.489014 2659.507568 2658.5354 2657.564697 2656.603516 2655.665527 2654.766846 2653.89209 2653.030518 2652.17334 2651.329834 2650.515137 2649.742676 2648.999512 2648.283936 2647.602539 2646.947998 2646.312256 2645.697266 2645.099609 2644.517334 2643.95459 2643.406006 2642.860596 2642.311279 2641.765625 2641.228027 2640.701416 2640.184814 2639.68457 2639.210205 2638.752686 2638.303711 2637.863281 2637.430908 2637.001709 2636.574951 2636.150635 2635.731201 2635.317139 2634.907471 2634.500977 2634.097412 2633.697021 2633.301025 2632.911621 2632.527344 2632.148193 2631.778809} {curve x1016 1610.689575 1610.689575 1609.913086 1609.123779 1608.324097 1607.51062 1606.666382 1605.77002 1604.843384 1603.907227 1602.966431 1602.017456 1601.064819 1600.108032 1599.148315 1598.183228 1597.208374 1596.22937 1595.254761 1594.291992 1593.332397 1592.366699 1591.380005 1590.386841 1589.405518 1588.458374 1587.523071 1586.568481 1585.570679 1584.552612 1583.528198 1582.501953 1581.469971 1580.427612 1579.371094 1578.304688 1577.226807 1576.133057 1575.028442 1573.914185 1572.787476 1571.6521 1570.513794 1569.373901 1568.231445 1567.087891 1565.939819 1564.789917 1563.641602 1562.491577 1561.34375 1560.209229 1559.092773 1557.991577 1556.909668 1555.8479 1554.807373 1553.804932 1552.861206 1551.956299 1551.078491 1550.234375 1549.415771 1548.605591 1547.797974 1546.997681 1546.197754 1545.397217 1544.597046 1543.793701 1542.980225 1542.16333 1541.357666 1540.565918 1539.785889 1539.026245 1538.296753 1537.588379 1536.892822 1536.209229 1535.538208 1534.885132 1534.255981 1533.644043 1533.043335 1532.448975 1531.865845 1531.307739 1530.786377 1530.289307 1529.811646 1529.353394 1528.913574 1528.485596 1528.075562 1527.676392 1527.27124 1526.852661 1526.427124 1525.993164 1525.544189}}
}
CurveTool {
avgframes 1
ROI {480 270 1440 810}
autocropdata {480 270 1440 810}
intensitydata {{curve x1016 0.6600334644 0.6600334644 0.6597902179 0.6595465541 0.6593059897 0.6590657234 0.6588294506 0.6585918665 0.65835917 0.6581236124 0.6578935385 0.6576542854 0.6574258804 0.6571981907 0.6569653153 0.6567382812 0.6565112472 0.6562783718 0.6560453176 0.6558170915 0.655583024 0.6553529501 0.6551214457 0.6548811197 0.6546438932 0.6544058323 0.6541666389 0.6539264321 0.6536849737 0.653442204 0.653198421 0.6529556513 0.6527141929 0.6524739265 0.6522376537 0.6520036459 0.6517715454 0.6515410542 0.6513118148 0.6508561373 0.6506290436 0.6504020691 0.6501748562 0.6499471664 0.6497186422 0.6494890451 0.6492580771 0.649025321 0.6487905979 0.6485534906 0.6483126879 0.6480706334 0.6478271484 0.6475837231 0.6473404169 0.6470989585 0.646856606 0.6466169357 0.6463782787 0.6461406946 0.6461406946 0.6459040046 0.6456680298 0.6454328299 0.645198226 0.6449641585 0.6449641585 0.6447305679 0.6445028782 0.644508481 0.6442756653 0.6442756653 0.6440429688 0.6438159347 0.6438215971 0.6435886025 0.6435886025 0.6433606744 0.64336586 0.643126905 0.6431318521 0.6428972483 0.6428972483 0.6426620483 0.6426620483 0.6424261332 0.6424261332 0.6424261332 0.6421893835 0.6421893835 0.6419516802 0.6419516802 0.6417105198 0.6417105198 0.6417105198 0.641471386 0.641471386 0.6412311196 0.6412311196 0.6412311196 0.6409884691 0.6409884691} {curve x1016 0.7418984771 0.7418984771 0.7414364815 0.7414381504 0.7409802675 0.7405247092 0.7400767207 0.73962605 0.7391847372 0.73873806 0.7382926345 0.7383018732 0.7378579378 0.7374252677 0.7369938493 0.7365524173 0.7361219525 0.735691309 0.7352495193 0.7348272204 0.7343925834 0.7339554429 0.7335152626 0.733065486 0.7326139808 0.7321605682 0.7317048907 0.7312486172 0.7307870388 0.7303240895 0.7298614979 0.729398489 0.7289364934 0.7284751534 0.7280173302 0.7275661826 0.7271137238 0.7266699076 0.7262217999 0.7253482938 0.724914968 0.7244832516 0.7240524292 0.7236219645 0.7231913209 0.7227495909 0.7218543291 0.7214203477 0.7209755182 0.7205374837 0.7200962305 0.7196510434 0.7191975713 0.7182790041 0.7178161144 0.717355907 0.7168951631 0.7164322138 0.7159719467 0.7155092359 0.7155092359 0.7150475979 0.7145862579 0.7141255736 0.7136688232 0.7132143378 0.7132143378 0.7127677798 0.7123180628 0.7118623257 0.7114149332 0.7114149332 0.710968852 0.7105240822 0.7100705504 0.7100705504 0.7096270919 0.7091742158 0.7087318897 0.7087424994 0.7083009481 0.7078703642 0.7078703642 0.7074398398 0.7074398398 0.707008779 0.706566453 0.706566453 0.7061235309 0.7061235309 0.7056888342 0.7056888342 0.7052434683 0.7052434683 0.7052434683 0.7048043013 0.7048043013 0.704361856 0.704361856 0.7038988471 0.7039048076 0.7039048076} {curve x1016 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0} 0}
name CurveTool
xpos 620
ypos 1239
}
push $N28cebdd0
Expression {
expr0 (r*width-x)*inv
expr1 (g*height-y)*inv
expr2 0
name UVMapToIDistort
xpos 290
ypos -9
addUserKnob {20 Invert}
addUserKnob {3 inv l invert}
inv 1
}
end_group
